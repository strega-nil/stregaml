variant type Bool {
  False,
  True,
}

integer type Int32 {
  bits = 32,
}

# note: short for a type with public data and no member functions
record type Cons {
  value: Int32,
  # this absolutely wouldn't work in "real" cafÃ©
  next: List,
}

variant type List {
  Nil: (),
  Cons: Cons,
}

infix group Cons {
  associativity = end,
}
infix (:-): Cons;
func (infix :-)(x: Int32, lst: List) -> List {
  List::Cons(Cons::{value = x, next = lst})
}

func (infix +)(x: Int32, y: Int32) -> Int32 {
  __builtin(add[Int32])(x, y)
}

func (infix <=)(x: Int32, y: Int32) -> Bool {
  __builtin(less_eq[Int32, Bool])(x, y)
}

func sum(x: ref List) -> Int32 {
  match (x) {
    List::Nil(_unit) => { Int32::0 }
    #{
      note: this currently binds to a copy of the list
      in the future, it should bind to a reference
    #}
    List::Cons(cons) => {
      cons.value + sum(cons.next)
    }
  }
}

@[entrypoint]
func main() -> Cons {
  let lst
    =  Int32::1
    :- Int32::2
    :- Int32::3
    :- Int32::4
    :- Int32::5
    :- Int32::6
    :- Int32::7
    :- Int32::8
    :- Int32::9
    :- Int32::10
    :- List::Nil(());

  # hax
  Cons::{
    value = sum(lst),
    next = lst,
  }
}
