integer type Int32 {
  bits = 32;
}

# note: short for a type with public data and no member functions
record type Cons {
  value: Int32;
  # this absolutely wouldn't work in "real" cafÃ©
  next: List;
}

variant type List {
  Nil: ();
  Cons: Cons;
}

infix group Cons {
  associativity = end;
}
infix (:-): Cons;
func (infix :-)(x: Int32, lst: List) -> List {
  List::Cons(Cons::{value = x; next = lst})
}

func (infix +)(x: Int32, y: Int32) -> Int32 {
  __builtin(add)(x, y)
}

func sum(x: ref List) -> Int32 {
  match (x) {
    List::Nil(_unit) => { 0 }
    #{
      note: this currently binds to a copy of the list
      in the future, it should bind to a reference
    #}
    List::Cons(cons) => {
      cons.value + sum(cons.next)
    }
  }
}

@[entrypoint]
func main() -> Cons {
  let lst = 1 :- 2 :- 3 :- 4 :- 5 :- 6 :- 7 :- 8 :- 9 :- 10 :- List::Nil(());
  # hax
  Cons::{
    value = sum(lst);
    next = lst;
  }
}
