Laid out in order of when I want to do them

* rework lvalues!
* effects
  - syntax:
    ```cafe
    effect Yield {
      func yield(Int32);
    }
    effect IoYield = Yield | Io;

    func generate() Yield { ... }
    func get_int() Io -> Int32 { ... }
    func input_stream() Io | Yield { ... }

    func print_all(f: func() Yield) {
      handle (f()) {
        Yield::yield(x) => {
          print(x);
          continue;
        }
        return => {}
      }
    }
    ```
* MIR
  - actually lay out types
    - check for recursive types
  - write an interpreter for MIR
  - LLVM backend
* externals
* linearity
* polymorphism!
  - syntax: `type Array[T: type, N: UInt]`
  - ```cafe
    func iter_map[
      T: type,
      U: type,
      E: effect,
    ](
      lst: List[T],
      f: func(T) E -> U,
    )
      Yield[Int32] | E
    {
      ...
    }
    ```
* real pattern matching
* implicit polymorphism!
  - ```cafe
    func iter_map(lst: List['t], f: func('t) 'e -> 'u)
      Yield[Int32] | 'e
    {
      ...
    }
    ```

* names for stuff
  * tamper - build
  * pour
  * pitcher
  * shot
  * grind[er]
  * roast
  * toddy
  * drip

* name for caf√© programmers - baristas
