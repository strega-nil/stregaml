* cleanup
  - abstract out the "filling out array" logic
    - "X_some : bool array + X : t array"
  - switch the remaining lists in the mid-end into arrays
    - preferably const arrays - do that when doing the above
* recursive types
  - first - check for it
  - second - see pointers
* LLVM backend
* externals
* real pattern matching
* effects
  - syntax:
    ```cafe
    effect Yield {
      func yield(Int32);
    }
    effect IoYield = Yield | Io;

    func generate() Yield { ... }
    func get_int() Io -> Int32 { ... }
    func input_stream() Io | Yield { ... }

    func print_all(f: func() Yield) {
      handle (f()) {
        Yield::yield(x) => {
          print(x);
          continue;
        }
        return => {}
      }
    }
    ```
* polymorphism!
  - syntax: `type Array[T: type, N: UInt]`
  - ```cafe
    func iter_map[
      T: type,
      U: type,
      E: effect,
    ](
      lst: List[T],
      f: func(T) E -> U,
    )
      Yield[Int32] | E
    {
      ...
    }
    ```
* implicit polymorphism!
  - ```cafe
    func iter_map(lst: List['t], f: func('t) 'e -> 'u)
      Yield[Int32] | 'e
    {
      ...
    }
    ```
* linearity

* names for stuff
  * tamper - build
  * pour
  * pitcher
  * shot
  * grind[er]
  * roast
  * toddy
  * drip

* name for caf√© programmers - baristas
